#! /usr/bin/env perl
#
# generate a nonlinear model
#
# Andrew Janke - a.janke@gmail.com
#
# Copyright Andrew Janke, The Australian National University.
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted,
# provided that the above copyright notice appear in all copies.  The
# author and the University make no representations about the
# suitability of this software for any purpose.  It is provided "as is"
# without express or implied warranty.


$| = 0;

use strict;
use warnings "all";
use Getopt::Tabular;
use File::Basename;
use File::Temp qw/ tempdir /;

# until I get organised and do this properly
my $PACKAGE = &basename($0);
my $VERSION = '1.1.0';
my $PACKAGE_BUGREPORT = '"Andrew Janke" <a.janke@gmail.com>';

my @nlin_conf = (
   {'step' => 16, 'blur_fwhm' => 16, 'iterations' => 4, 'modelstep' => 2.0},
   {'step' =>  8, 'blur_fwhm' =>  8, 'iterations' => 8, 'modelstep' => 1.5},
   {'step' =>  4, 'blur_fwhm' =>  4, 'iterations' => 8, 'modelstep' => 1.0},
   {'step' =>  2, 'blur_fwhm' =>  2, 'iterations' => 4, 'modelstep' => 0.5},
   );


my($Help, $Usage, $me, $history);
my(@opt_table, %opt, @infiles, @args);

$me = &basename($0);
%opt = (
   'verbose' => 0,
   'clobber' => 0,
   'fake' => 0,
   'keep_tmp' => 0,
   'workdir' => "./$me-work",
   'batch' => 0,
   'symmetric' => 0,
   'extend' => 10,
   'config_file' => undef,
   'init_model' => undef,
   'output_model' => undef,
   'fit_stages' => 'lin,lin,lin,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3',
   );

$Help = <<HELP;
| $me makes a model via lots of processing....
|
| To add an additional step, you will need to add another stanza
|    to the \@nlin_conf array;
|
| # example configuration file (fit.conf) for $me
| \@nlin_conf = (
|    {'step'         => 16,
|     'blur_fwhm'    => 8,
|     'iterations'   => 3,
|     },
|
|    {'step'         => 8,
|     'blur_fwhm'    => 4,
|     'iterations'   => 2,
|     },
|
|    {'step'         => 4,
|     'blur_fwhm'    => 4,
|     'iterations'   => 2,
|     },
|   );
| 
|
| Problems or comments should be sent to: a.janke\@gmail.com
HELP

$Usage = "Usage: $me [options] <in1.mnc> [<in2.mnc> [...]]\n".
         "       $me -output_model model.mnc in1.mnc in2.mnc in3.mnc in4.mnc\n".
         "       $me -help to list options\n\n";

@opt_table = (
   ["General Options", "section" ],
   ["-version", "call", 0, \&print_version_info,
      "print version and exit" ],
   ["-verbose", "boolean", 0, \$opt{verbose},
      "be verbose" ],
   ["-clobber", "boolean", 0, \$opt{clobber},
      "clobber existing check files" ],
   ["-fake", "boolean", 0, \$opt{fake},
      "do a dry run, (echo cmds only)" ],
   ["-workdir", "string", 1, \$opt{workdir},
      "working directory to use (multiple GB needed)" ],
   ["-batch", "boolean", 0, \$opt{'batch'},
      "use a batch system for processing (qbatch)" ],
      
   ["Fitting Options", "section" ],
   ["-extend", "integer", 1, \$opt{extend},
      "extend the volume by # slices before fitting to avoid edge effects",
      "<integer>" ],
   ["-symmetric", "boolean", 0, \$opt{symmetric},
      "create a symmetric model" ],
   ["-config_file", "string", 1, \$opt{config_file},
      "file containing the fitting configuration use -help for format",
      "<fit.conf>" ],
   ["-init_model", "string",  1, \$opt{'init_model'}, 
      "initial starting model to use [Default: first input file]" ],
   ["-output_model", "string",  1, \$opt{'output_model'}, 
      "output model name to use [Default: <dir of first infile>/VolModel-<stage>]" ],
   ["-fit_stages", "string", 1, \$opt{'fit_stages'},
      "comma separated list of stages of fitting to perform" ],
   );
   
# get history string
chomp($history = `date`);
$history .= '>>>> ' . join(' ', $me, @ARGV);

# store orig command in case running in batch mode
my @orig_cmd = ($0, @ARGV);

# Check and get arguments
&Getopt::Tabular::SetHelp($Help, $Usage);
&GetOptions (\@opt_table, \@ARGV) || exit 1;
die $Usage if $#ARGV < 0;
@infiles = @ARGV;

# setup the fit stages
my @fit_stages = split(',', $opt{'fit_stages'});

# check for infiles and create files array
print STDOUT "+++ INFILES\n" if $opt{'verbose'};
my(@dirs, @files, %fileh, $c);
$c = 0;
foreach (@infiles){
   my($dir, $f, $c_txt);
   
   $c_txt = sprintf('%04d', $c);
   
   # check
   die "$me: Couldn't find file: $_\n" if !-e $_;
   
   # set up arrays
   $dirs[$c] = &dirname($_);
   $files[$c] = "$c_txt-" . &basename($_);
   $files[$c] =~ s/\.mnc$//;
   $fileh{$files[$c]} = $c;
   
   print STDOUT "  | [$c_txt] $dirs[$c] / $files[$c]\n" if $opt{'verbose'};
   $c++;
   }

# check for output model
$opt{'output_model'} = "$dirs[0]/VolModel-ALL.mnc" if !defined($opt{'output_model'});
if(-e $opt{'output_model'} && !$opt{clobber}){
   die "$me: $opt{'output_model'} exists, use -clobber to overwrite\n\n";
   }

# make working dir
&do_cmd('mkdir', $opt{'workdir'}) if !-e $opt{'workdir'};

# save the original command for later use
open(FH, '>', "$opt{'workdir'}/orig-command-$$.sh");
print FH "#! /bin/sh\n" .
         "#\n".
         "# volgenmodel script\n\n" .
         join(' ', @orig_cmd) ."\n";
&do_cmd('chmod', '+x', "$opt{'workdir'}/orig-command-$$.sh");
&do_cmd('ln', '-s', '-f', "orig-command-$$.sh", "$opt{'workdir'}/orig-command-last.sh");

my(@conf, @regfiles, $cmodel, $initxfm);

# set up the @conf array
if(defined($opt{config_file})){
   my($buf);
   $buf = `cat $opt{config_file}`;
   
   # slurp
   if(eval($buf)){
      print STDOUT "$me: Read config from $opt{config_file}\n" if $opt{verbose};
      }
   else{
      die "$me: Error reading config from $opt{config_file} (fix it!)\n\n";
      }
   }
else{
   @conf = @nlin_conf;
   }

# extend if we have to and setup @regfiles in the process
if($opt{extend} > 0){
   my($paddir, $f);
   
   print STDOUT "+++ Padding and setting up regfiles\n";
   
   $paddir = "$opt{'workdir'}/pad";
   &do_cmd('mkdir', '-p', $paddir);
   
   for($f=0; $f<=$#files; $f++){
      $regfiles[$f] = "$paddir/$files[$f].pad.mnc";
      
      if(&mcomplete($regfiles[$f])){
         printf STDOUT "   | $regfiles[$f] - exists, skipping\n";
         }
      else{
         printf STDOUT "   | $regfiles[$f] - padding\n";
         &do_cmd_batch("PAD$$-$f", 'none',
                       'volpad', '-clobber', 
                       '-distance', $opt{'extend'},
                       '-smooth',
                       '-smooth_distance', 4,
                       $infiles[$f], $regfiles[$f]);
         }
      }
   }
else{
   @regfiles = @infiles;
   }

# setup the initial model
print STDOUT "+++ Setting up the initial model\n";
if(defined($opt{'init_model'})){
   $cmodel = $opt{'init_model'};
   }
else{
   # create the initial model from the "first" file
   $cmodel = "$opt{'workdir'}/00-init-model_blur.mnc";
   if(&mcomplete($cmodel)){
      printf STDOUT "   | $cmodel - exists, skipping\n";
      &do_cmd_batch("BLR$$-init-model", "PAD$$-$files[0]",
                    'true');
      }
   else{
      printf STDOUT "   | $cmodel - creating\n";
      &do_cmd_batch("BLR$$-init-model", "PAD$$-$files[0]",
                    'mincblur', '-clobber',
                    '-fwhm', 4,
                    $regfiles[0], "$opt{'workdir'}/00-init-model");
      }
   }

# create an approriate identity transformation
$initxfm = "$opt{'workdir'}/ident-$nlin_conf[0]{'step'}.xfm";
&do_cmd_batch("IDT$$", "BLR$$-init-model",
              'gennlxfm', '-clobber',
              '-like', $cmodel,
              '-step', $nlin_conf[0]{'step'},
              $initxfm);


# get last linear stage from fit config
my($snum, $lastlin, $s, $end_stage);
$snum = 0;
$lastlin = '00';
foreach $s (@fit_stages){
   if($s eq 'lin'){
      $lastlin = sprintf("%02d",$snum);
      }
   $snum++;
   }
print STDOUT "+++ Last Linear stage: $lastlin\n";


# Foreach end stage in the fitting profile
print STDOUT "+++ Fitting\n";
$snum = 0;
foreach $end_stage (@fit_stages){
   my($snum_txt, $f, $cworkdir, $avgfile, $stdfile, $isomodel, $conf_fname, 
      @modxfm, $avgxfm, $concatxfm, @rsmpl, $iavgfile, $symxfm);
   
   $snum_txt = sprintf("%02d", $snum);
   print STDOUT "  + [Stage: $snum_txt] End stage: $end_stage\n";
   
   # make subdir in working dir for files
   $cworkdir = "$opt{'workdir'}/$snum_txt";
   &do_cmd('mkdir', $cworkdir) if !-e $cworkdir;
   
   # set up model names and check if this step is done (already)
   $avgfile = "$cworkdir/model.avg.mnc";
   $stdfile = "$cworkdir/model.std.mnc";
   if(&mcomplete($avgfile) && &mcomplete($stdfile)){
      printf STDOUT "   | $avgfile - exists, skipping\n";
      $cmodel = $avgfile;
      $snum++;
      next;
      }
   
   # create the ISO model
   $isomodel = "$cworkdir/fit-model-iso.mnc";
   printf STDOUT "   | $isomodel - creating\n";
   if(&mcomplete($isomodel)){
      &do_cmd_batch("ISO$$-$snum_txt-model", "BLR$$-init-model",
                    'true');
      }
   else{
      my $targetstep = $nlin_conf[(($end_stage eq 'lin') ? 0 : $end_stage)]{'modelstep'};
      &do_cmd_batch("ISO$$-$snum_txt-model", "BLR$$-init-model",
                    'voliso', '-clobber',
                    '-maxstep', $targetstep,
                    $cmodel, $isomodel);
      }
   $cmodel = $isomodel;
   
   # linear or nonlinear fit
   if($end_stage eq 'lin'){
      print STDOUT "---Linear fit---\n";
      }
   else{
      print STDOUT "---Non Linear fit---\n";
      
      # create nlin fit config
      if($end_stage ne 'lin'){
         $conf_fname = "$cworkdir/$end_stage-fit.conf";
         print STDOUT "    + Creating $conf_fname +\n";
         
         open(CONF, ">$conf_fname");
         print CONF "# $conf_fname -- created by $me\n\n";
         print CONF "\@conf = (\n";
         foreach $s (0..$end_stage){
            print CONF "   {'step' => " . $nlin_conf[$s]{'step'} .
               ", 'blur_fwhm' => " . $nlin_conf[$s]{'blur_fwhm'} .
               ", 'iterations' => " . $nlin_conf[$s]{'iterations'} . "},\n";
            }
         print CONF "   );\n";
         close(CONF);
         }
      }
   
   # register each file in the input series
   for($f=0; $f<=$#files; $f++){
      $modxfm[$f] = "$cworkdir/$files[$f].xfm";
      
      if(&mcomplete($modxfm[$f])){
         printf STDOUT "---$modxfm[$f] exists, skipping---\n";
         &do_cmd_batch("FIT$$-$snum_txt-$f", "ISO$$-$snum_txt-model",
                       'true');
         }
      else{
         if($end_stage eq 'lin'){
            &do_cmd_batch("FIT$$-$snum_txt-$f", "ISO$$-$snum_txt-model",
                          'bestlinreg', '-clobber',
                          $cmodel, $regfiles[$f], $modxfm[$f]);
            }
         else{
            # use the last linear xfm as a starting point
            my $initcnctxfm = "$cworkdir/$files[$f].cnct.xfm";
            &do_cmd_batch("IXF$$-$snum_txt-$f", "ISO$$-$snum_txt-model,IDT$$",
                          'xfmconcat', '-clobber', 
                          "$opt{'workdir'}/$lastlin/$files[$f].xfm", $initxfm, $initcnctxfm);
            
            &do_cmd_batch("FIT$$-$snum_txt-$f", "IXF$$-$snum_txt-$f",
                          'nlpfit', '-clobber',
                          '-init_xfm', $initcnctxfm,
                          '-config', $conf_fname,
                          $cmodel, $regfiles[$f], $modxfm[$f]);
            }
         }
      }
   
   # average xfms
   $avgxfm = "$cworkdir/avgxfm.xfm";
   &do_cmd_batch("AXF$$-$snum_txt", "FIT$$-$snum_txt-*",
                 'xfmavg', '-clobber',
                 (($end_stage eq 'lin') ? '-ignore_nonlinear' : '-ignore_linear'),
                 @modxfm, $avgxfm);
   
   # resample each file in the input series
   for($f=0; $f<=$#files; $f++){
      $concatxfm = "$cworkdir/concat-$files[$f].xfm";
      $rsmpl[$f] = "$cworkdir/rsmpl-$files[$f].mnc";
      
      if(&mcomplete($rsmpl[$f])){
         printf STDOUT "   | $rsmpl[$f] - exists, skipping\n";
         }
      else{
         printf STDOUT "   | $rsmpl[$f] - resampling\n";
         
         # first remove due to dodgy xfmtool code with no -clobber
         my $gridfn = $concatxfm;
         $gridfn =~ s/\.xfm$/\_grid\_0\.mnc/;
         &do_cmd('rm', '-f', $concatxfm, $gridfn);
         
         # concat xfms
         &do_cmd_batch("XCN$$-$snum_txt-$f", "AXF$$-$snum_txt",
                       'xfmtool', "invert:$modxfm[$f]", $avgxfm, $concatxfm);
         
         # resample
         &do_cmd_batch("RES$$-$snum_txt-$f", "XCN$$-$snum_txt-$f", 
                       'mincresample', '-clobber',
                       '-sinc',
                       '-transformation', $concatxfm,
                       '-like', $cmodel,
                       $infiles[$f], $rsmpl[$f]);
         }
      }
   
   # create model
   $iavgfile = "$cworkdir/model.iavg.mnc";
   &do_cmd_batch("IAV$$-$snum_txt", "RES$$-$snum_txt-*",
                 'mincaverage', '-clobber',
                 '-double',
                 '-sdfile', $stdfile,
                 @rsmpl, $iavgfile);
   
   # do symmetric averaging if required
   $symxfm = "$cworkdir/model.sym.xfm";
   if($opt{'symmetric'}){
      my @fit_args;
      
      # set up fit args
      if($end_stage eq 'lin'){
         @fit_args = ('-linear');
         }
      else{
         @fit_args = ('-nonlinear', '-config_file', $conf_fname);
         }
      
      &do_cmd_batch("SYM$$-$snum_txt", "IAV$$-$snum_txt",
                    'volsymm', '-clobber',
                    @fit_args,
                    $iavgfile, $symxfm, $avgfile);
      }
   else{
      &do_cmd_batch("SYM$$-$snum_txt", "IAV$$-$snum_txt", 'true');
      }
   
   # if on last step, copy model to $opt{'output_model'}
   if($snum == $#fit_stages){
      &do_cmd_batch("FNL$$-$snum_txt", "SYM$$-$snum_txt",
                    'cp', '-i', $avgfile, $opt{'output_model'});
      
      # add the history string to the output file
      &do_cmd_batch("HIS$$-$snum_txt", "FNL$$-$snum_txt",
                    'minc_modify_header', 
                    '-sappend', ":history='$history'", 
                    $opt{'output_model'});
      }
   else{
      &do_cmd_batch("FNL$$-$snum_txt", "SYM$$-$snum_txt", 'true');
      
      # and now we get to some ugly spaghetti(ish) code whereby we resubmit ourselves
      # for the next iteration and then exit
      if($opt{'batch'}){
         &do_cmd_batch("STG$$-$snum_txt", "FNL$$-$snum_txt", @orig_cmd);
         exit(0);
         }
      }
   
   $cmodel = $avgfile;
   $snum++;
   } # end stage loop


sub do_cmd { 
   print STDOUT "@_\n" if $opt{verbose};
   if(!$opt{fake}){
      system(@_) == 0 or die;
      }
   }

# run a command possibly via batch
# 1st param: Job Name
# 2nd param: Depends string
# remainder: command
sub do_cmd_batch {
   my($name, $depends, $logdir);
   $name = shift(@_);
   $depends = shift(@_);
   
   $logdir = "$opt{'workdir'}/log";
   &do_cmd('mkdir', '-p', $logdir) if (!-e $logdir);
   
   print STDOUT "[$name:$depends] - @_\n" if $opt{verbose};
   if(!$opt{fake}){
      
      if($opt{'batch'}){
         print '   [B] ';
         &do_cmd('qbatch', 
                 '-logfile', "$logdir/$name.log",
                 '-N', $name,
                 '-depends', $depends,
                 '--',
                 @_);
         }
      else{   
         &do_cmd(@_);
         }
      }
   }

sub print_version_info {
   print STDOUT "\n$PACKAGE version $VERSION\n".
                "Comments to $PACKAGE_BUGREPORT\n\n";
   exit 0;
   }

# little function to test if a minc or xfm file is complete (and exists)
sub mcomplete {
   my $infile = shift(@_);
   
   chomp(my $buf = `minccomplete -error_string 1 $infile`);
   
   return ($buf == 0) ? 1 : 0;
   }
